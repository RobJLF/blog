---
title: 犀牛-第6章-对象
permalink: model
date: "2019/7/16"
mathjax: true
tags: 
- JS
- 犀牛书
categories: JS
---

# 第6章-对象

## 简介

其实所有的对象都可以看做空对象，但是可以通过`_proto_`和`prototype`给该空对象加上相应的身份，无论何时请问自己这么一个问题，空对象的`_proto_`和`prototype`是什么，又是通过什么方式决定的

1. 对象简单来说就是字符串到值的映射，可以从一个原型对象继承属性，也可以新增属性删除属性
2. 除了字符串、数字、true、false、null和undefined之外，JavaScript中的其他值都是对象
3. 对象可以创建、设置、查找、删除、检测和枚举它的属性
4. 属性名可以是包含空字符串在内的任意字符串，但不能有同名的属性；属性值可以是任意JavaScript值，或者是一个getter或者setter函数（`6.6`）；除了名值之外，每个属性还是以一些相关的特性，称为属性特性：
   - 可写（可设置该值）、可配置（可删除修改）、可枚举(for/in中能否读出)、value *枚删改值*
   - get/set、 可配置、可枚举 *枚删get/set*
   - 属性通过**o.x=y**形式创建默认是true，但是通过Object.defineProperty创建默认值是false
5. 每个对象还有相关的对象特性：（`6.1.3 6.2.2 6.8`）会进一步讲解
   - 对象原型(prototype):指向另一个对象，本对象的属性可以从原型对象中继承
   - 对象的类(class):是一个标识对象类型的字符串
   - 对象的扩展标记(extensible flag):指明了是否可以向该对象添加新属性
6. 对JavaScript对象和两类属性作区分：
   - 内置对象：由ECMAScript规范定义的对象和类。例如，数组、函数、日期和正则表达式都是内置对象
   - 宿主对象：JavaScript引擎嵌入的宿主环境决定的(如Web浏览器)。
   - 自定义对象：运行的JavaScript代码创建的对象
   - 自有属性：直接在对象中定义的属性
   - 继承属性：从对象的原型对象中定义的属性

## 6.1 创建对象

三种方式：对象直接量、关键字new和Object.create()函数

### 6.1.1 对象直接量

```js
逗号分隔名值对，冒号分隔名值
var empty = {};
var point = {x:0,y:0};
var book = {
  "main title":"JavaScript",
  "sub-title":"The Definitive Guide",
  "for":"all audiences",
  author:{
    firstname:"David",
    surname:"Flanagan"
  }
}
```

1. 属性名可以是标识符和字符串`直接量`(可空字符串)；属性值可以是任意类型的JavaScript表达式。
2. ES5中保留字可以不带引号用做属性名；对象直接量中最后一个属性后的逗号忽略，IE中会报错。
3. 每次执行对象直接量都会创建一个新的对象。

### 6.1.2 通过new创建对象

通过new后跟一个构造函数来创建对象

```js
var o = new Object();
var a = new Date();
```

后面详细讲

### 6.1.3 对象的原型`__proto__`

1. 对象直接量`{}`的原型`__proto__`：Object.prototype
2. 通过new创建`内置/自定义`对象的原型`__proto__`：对应构造函数的`prototype`
3. 每个函数的都有`prototype`属性，指向它们的原型，而他们的原型里又会有`constructor`属性指回该函数。
4. 创建函数时默认就会创建该函数的原型prototype，且一般只有函数才有prototype，非函数的`prototype==undifined`
5. 函数的`__proto__`指向`Function.prototype`
6. 函数的原型`prototype`的属性值`__proto__`一般都是`Object.prototype`，内置构造函数的原型都遵守该条(除Object)。
   - `Object.prototype.__proto__===null`
   - `Object.prototype.prototype===undefined`
   - `Date.prototype.__proto__===Object.prototype`
   - `Date.prototype.prototype===undefined`
7. `6.2.2 6.8.1 9章都会详细地讨论这些内容`

### 6.1.4 Object.create()

**如何确定一个对象`__proto__`属性：**
**1.通过new构造函数，使对象的`__proto__`指向构造函数的原型`prototype`**
**2.通过Object.create()创建一个空对象，然后使空对象的`__proto__`指向函数的内部参数**

1. 一个静态方法(其内部不引用this)，创建一个新对象，其中第一个参数是这个对象的原型`__proto__`，第二个参数是可选的，用来对对象的属性进行描述(6.7)
2. 直白的说就是创建一个空对象，然后修改它的`__proto__`属性指向为该方法的第一个参数；也就是说可以通过任意原型创建对象
3. 如果第一个参数是null，则是一个没有原型的对象，和Object.prototype一样没有`__proto__`属性

```js
function inherit(p) {
  if(p == null) throw TypeError();
  if(Object.create)
    return Object.create(p);
  var t = typeof p;
  if(t !== "object" && t !== "function") throw TypeError();
  function f(){}
  f.prototype = p; //p.constructor可不是指向f的
  return new f();
  //为什么非要用构造函数来创建，就不能直接创建一个空对象，然后改变它的`__proto__`属性，还是说这个`__proto__`属性不够标准，最好不要用?
}
```

inherit生成的对象相当于继承了p的属性，这时候通过新生成的对象就无法修改父类的属性了，只能修改自身属性。

## 6.2 属性的查询和设置

使用点`.`运算符和方括号`[]`运算符来获取属性的值，4.4节有讲过。不过ES5之后可以在.后面直接使用保留字。

```js
var author = book.author; //查询
book.author = 1; //设置
```

### 6.2.1 作为关联数组的对象

```js
下面两个表达式的值相等
object.property;
object['property']
```

1. 第一种使用标识符，第二种使用方括号和字符串，更像是数组，只不过索引是字符串不是数字。这种数组就是我们说的关系数组，也称为散列、映射或字典。JavaScript对象都是关联数组。
2. C C++ Java这些强类型语言中对象都只能拥有固定数目的属性，并且必须是提前定义好的；JavaScript这种弱类型语言可以在程序执行中动态的创建属性
3.`[]`相比于`.`而言更加的灵活，因为其内容是可动态创造的，而`.`后面的标识符是在程序执行前就写死的。

### 6.2.2 继承属性（这里关于修改和添加属性的具体细节后面会讲）

1. JavaScript对象具有"自有属性"，也有"继承属性"
2. 如果说查询对象o中的属性x，如果o中没有x属性，那么会继续在o的原型对象中查询属性x，如果还没有找到x，会依次沿着原型对象往上查，直到找到x属性，或者找到一个原型为null的对象并返回undefined为止。
3. 给对象o的属性x赋值，如果o有属性x，且该属性writable，那么改变属性值；如果o没有属性x，且原型中没有x属性，那么赋值操作给o添加一个新属性x，如果属性x在原型链中存在且为writable，那么o同样创建一个同名属性x覆盖继承属性。
4. 属性赋值操作首先会检查原型链，判断是否允许赋值操作(6.2.3) 。如果o继承了一个只读属性x，那么赋值操作是不允许的。如果允许赋值操作，那么它总是在当前对象上创建属性或对已有的属性进行修改，而不会去修改原型链。(原型链是不会受到影响的)
5. 属性赋值要么失败，要么创建一个属性，要么在原始对象中修改属性值。但还是有一个例外，如果对象o继承属性o，而这个属性是getter或setter方法，那么此时的操作将会以对象o为函数调用对象，然后调用该函数。

### 6.2.3 属性访问错误

1. 查询一个不存在的属性并不会报错，而是返回undefined。
2. 对null和undefined进行属性查询会报错
`var len = book && book.subtitle && book.subtitle.length`
这样可以防止null或者undefined时的类型访问错误
3. 设置属性失败在严格模式下抛类型错误异常
在这些场景下给o对象设置属性p会失败
   - o中的属性p是只读的：不能给只读属性重新赋值(如果是可配置的，那么可以先将其修改为可写的，然后再赋值)
   - o中的属性p是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性
   - o中不存在自有属性p，o没有使用setter方法继承属性p，且o的可扩展性是false：如果o没有属性p，而且没有setter方法可调用，那么p一定会添加到o中(排除第二种情况);但是o不是可扩展的，所以在o中不能定义新的属性

## 6.3删除属性

1. delete运算符用于断开属性和对象之间的关系，操作数应该是一个属性访问表达式。
2. delete只删除自有属性，不删除继承属性
3. delete删除一个不存在的属性或者说操作数不是一个属性访问表达式，返回true

    ```js
    o = {x:1};
    delete o.x //true
    delete o.x //true
    delete o.toString //true 因为toString是继承属性，什么都没有做
    delete 1； //true
    ```

4. delete不能删除那些可配置性为false的属性，严格模式中删除一个不可配置属性回报类型错误。非严格模式中返回false

## 6.4 检测属性

**in运算符** *(own+proto)*  
> in运算符左边是属性名(字符串)，右边是对象。如果对象的继承属性或自有属性> 中包含这个属性则返回true

```js
var o = {x:1}
"x" in o; //true
"y" in o; //false
"toString" in o; //true

访问不存在的属性 返回 undefined，但是返回 undefined 不能得出属性不存在
通过in运算符就可以用于区分不存在的属性和值为undefined的属性
```

**hasOwnProperty()方法** *(own)*  
> 检测给定的名字是否是对象的自有属性，对继承属性返回false

```js
var o = {x:1}
o.hasOwnProperty("x");
o.hasOwnProperty("toString"); //false
```

**propertyIsEnumerable()** *(enum)*  
> 检测对象的自有属性，且该属性的可枚举性为true时才返回true

```js
Object.prototype.propertyIsEnumerable("toString");//false 因为不可枚举
```

## 6.5枚举属性

除了检测属性的存在与否，我们还经常遍历对象的属性。通常使用for/in循环遍历

**for/in** *(own+proto)\*enum*  
> 可以遍历对象中所有可以枚举的属性包括自有和继承，然后把属性名赋值给循环> 变量。`内置方法是不可枚举的（toString等）`

更多实例看书

```js
//把p中的可枚举的属性复制到o中，并返回o
function extend(o, p) {
  for(prop in p) {
    o[prop] = p[prop];
  }
}
```

**Object.keys()** *(own)\*enum*  
> 返回一个数组，由对象中可枚举的自有属性的名称组成。

**Object.getOwnPropertyNames()** *(own)*  
> 和上一个类似，返回所有自有属性的名称的数组，包括不可枚举的属性

## 6.6属性getter和setter

1. 由getter和setter定义的属性又叫做"存取器属性"，查询时调用getter方法，赋值时调用setter方法。
2. 存取器属性不具有可写性和value，通过是否具有这两个函数来判断该属性的value/可写性。

    ```js
    通过对象直接量来定义存取器属性
    var o={
      data_prop:value,
      get accessor_prop(){},
      set accessor_prop(){}
    }
    ```

3. 存取器属性定义一个或者两个和属性同名的函数，函数定义使用set和get而不是function,且没有使用冒号将属性名和函数体分开。
4. 存取器函数中的this指向它的调用对象
5. 该属性更像是一个对象的函数，只是调用的时候不用带()，更多例子请看书

## 6.7 属性的特性

1. 数据属性的4个特性：值(value)、可写性(writable)、可枚举性(enumerable)和可配置性(configurable)
2. 存取器属性4个特性：读取(get)、写入(set)、可枚举性和可配置性
3. ES5定义了属性描述符对象用于查询和设置属性特性。

**Object.getOwnPropertyDescriptor()**  
用于获取某个对象的某个自有属性的属性描述符对象。

```js
Object.getOwnPropertyDescriptor({x:1}, "x")
//{value:1,writable:true,enumerable:true,configurable:true}
Object.getOwnPropertyDescriptor(random, "octet")
//{get:/*fun*/,set:undefined,enumerable:true, configurable:true}
Object.getOwnPropertyDescriptor({}, "x")
//undefined 没有
Object.getOwnPropertyDescriptor({}, "toString")
//undefined 继承 想访问继承属性需要遍历原型链getPrototypeOf()
```

**Object.defineProperty()**

1. 用于新建、修改属性的特性；传入要修改的对象、属性的名称和描述符对象

    ```js
    Object.defineProperty(o, "x", {value:1, writable:true, enumerable:false, configurable:true});
    更多例子看书吧
    ```

2. 使用该方法新建的属性默认的特性值为false或者undefined，修改的属性特性值不变。只能用于自有属性，不能上升到继承属性。
3. 使用Object.defineProperties()来创建多个属性

    ```js
    Object.defineProperties(o, {
    x:{value:1, writable:true, enumerable:false, configurable:true},
    y:{value:2, writable:true, enumerable:false, configurable:true}
    r:{get: function(){}}
    });
    ```

4. Object.defineProperties和Object.defineProperty具体使用细节，违反都会抛出异常（不可写就意味着不能使用"="赋值）
   - 如果对象是不可扩展的，不能给它添加属性
   - 如果属性是不可配置的， 不能修改它的可配置性和可枚举性
   - 如果存取器属性是不可配置的，则不能修改器getter和setter方法，也不能将它转为数据属性(加上第二条等于锁死此属性)
   - 如果数据属性是不可配置的，则不能将它转为存取器属性(加上第二条等于除了writable和value以外锁死)
   - 如果数据属性是不可配置的，则不能将它的可写性由false变为true，但是可以从true变为false
   - 如果数据属性是不可配置且不可写的，则不能修改它的值`无论是=赋值还是Object.defineProperty都不能改变value`。然而可配置不可写是可以曲线救国的修改其值的。
5. 如果说`o.x=5`新建了一个属性，那么它默认的属性特性都为true。所以之前的extends函数不会复制属性的特性。具体看书吧。(就是使用了上面的两个函数而已)

## 6.6 对象的三个属性

原型prototype、类class和可扩展性

### 6.6.1 原型属性`__proto__`

1. 这里的原型在Firefox中指的是`__proto__`属性
2. 对象直接量的原型为Object.prototype,new关键字创建的对象使用构造函数的原型，Object.create()创建的对象使用第一个参数最为原型
3. 将对象作为参数传入Object.getPrototypeOf()可以查询该对象的原型；检测一个对象是不是在另一个对象的原型链上使用方法isPrototypeOf()
4. isPrototypeOf()和instanceof运算符有些类似，p instanceof o相当于o.prototype.isPrototypeOf(p)

    ```js
    var p={};
    var o=Object.create(p);
    p.isPrototypeOf(o)//true
    Object.prototype.isPrototypeOf(o)//true
    ```

### 6.8.2 类属性

1. 是一个字符串，用于表示对象的类型信息。ES5还没有这个方法，默认使用Object.toString来查询类属性。

    ```js
    fucntion classof(o) {
      if(o===null) return "null"; /* 可以不要 */
      if(o===undefined) return "undefined" /* 可以不要 */
      return Object.prototype.toString.call(o).slice(8, -1);
      /* 可以考虑使用o.constructor.name，但需要单独判断null, undefined */
    }
    ```

2. ES5内置对象的类属性就是构造函数名；宿主对象依靠具体实现；自定义对象和自定构函数创建的对象，类属性都是Object。

    ```js
    classof(null) //Null
    classof(1) //Number
    classof("") //String
    classof(false) //Boolean
    classof({}) //Object
    classof([]) //Array
    classof(//) //Regexp
    classof(new Date()) //Date
    classof(window) //Window
    function f(){}
    classof(new f()) //Object
    ```

### 6.8.3可扩展性

1. 可扩展性表示是否可以给对象添加新属性,内置对象和自定义对象都是可扩展的；宿主对象可扩展性由JavaScript引擎决定。
2. 将对象传入Object.isExtensible()来判断对象是否可扩展，传入Object.preventExtensions()来将对象转为不可扩展的，注意该操作是不可逆的，但是只影响自有属性。
3. Object.seal()和Object.preventExtensions()类似，不仅不可扩展，所有自有属性都设置为不可配置的。该操作也不可逆，可以通过Object.isSealed()进行检测
4. Object.freeze()更严的锁定对象--"冻结" 。不可扩展、不可配置且只读(存取器属性不受影响)，Object.isFreeze()用于检测
5. 以上三个方法均返回传入的对象，所以可以嵌套调用

## 6.9 序列化对象

1. 对象序列化是指将对象转为字符串，也可将字符串还原为对象。
2. 方法JSON.stringify()和JSON.parse()用来序列化和还原JavaScript对象。
3. 具体细节看官方文档或书本的参考部分

## 6.10 Object对象方法

几乎所有的JavaScript对象继承至Object.prototype，所以它们都会继承它的方法。

### 6.10.1 toString()方法

1. Object.prototye的toString()返回值和类属性相关的字符串。
2. 很多类都有自定义的toString()

### 6.10.2toLocaleString()方法

1. 返回本地化的字符串，Array类的toLocalString()使得每个数组元素都调用该方法

### 6.10.3 toJSON()

1. FireFox拥有Object.prototype.toSource方法来返回对象的序列化，但是chrome上没有

### 6.10.4 valueOf()

1. 和toString()很类似，当需要将对象转化为某种原始值而不是字符串的时候调用该函数
