---
title: 犀牛-第8章-函数
permalink: method
date: "2019/7/18"
mathjax: true
tags: 
- JS 
- method
- 犀牛书
categories: JS
---
## 第8章-函数

1. 函数也是对象 `其__proto__指向Function.prototype==Function.__proto__`
2. 函数的形参类似在函数体中新建的局部变量，除了形参还会传入this值和arguments两个值
3. 函数如果是对象的一个属性，那么可以称为方法，通过对象调用方法时，方法的调用上下文this指向此对象。（更多关于this的内容后面还会在提）

    ```js
    var name = "The Window";
    var object = {
      name : "My Object",
      getName: function(){
        return this.name;
      }
    };

    object.getName(); //"My Object"
    (object.getName)(); //"My Object"
    (object.getName = object.getName)(); //"The Window"，在非严格模式下
    ```

4. 第一行代码跟平常一样调用了object.getName()，返回的是"My Object"，因为this.name就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只是在引用一个函数，但this 的值得到了维持，因为object.getName 和(object.getName)的执行过程是相同的。第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以this 的值不能得到维持，结果就返回了"The Window"。  
当然，你不大可能会像第二行和第三行代码一样调用这个方法。不过，这个例子有助于说明即使是语法的细微变化，都有可能意外改变this 的值。

## 8.1 函数定义

1. 函数定义分为函数表达式和函数声明两种，都会使用function关键字来进行定义

    ```js
    /* 函数声明 */
    sayHi(); /* 声明会提前 */
    function sayHi(){
      alert("Hi!");
    }
    /* 函数表达式 */
    var functionName = function(arg0, arg1, arg2){
      //函数体
    };
    var functionName2 = function FunctionA(arg0, arg1, arg2){
      //函数体
    };
    ```

2. 函数表达式可以赋值给变量，这样做可以用于函数的递归；函数声明的方式最好不要通过函数名进行递归，使用arguments.callee来调用递归可以预防函数名变化导致的调用失败`(定义了函数名的函数表达式不会有此问题)`
3. 函数表达式定义的函数，函数名将是可选项，如果包含函数名，那么该名称将成为函数内部的一个局部变量，指向函数自己；函数声明相当于没有函数名的函数表达式`（就函数名而言）`
4. 函数声明语句会将会被提前到外部脚本或者外部作用域的顶部；而函数表达式只会将变量的声明提前，而不会将变量的赋值提前，这一点和变量的声明一样

    ```js
    sayHi(); //错误：函数还不存在
    var sayHi = function(){
      alert("Hi!");
    };
    ```

5. 没有return函数返回undefined，有return但其后没有表达式返回undefined
6. 函数声明语句只能出现在顶层语句中`(只能出现在全局作用域或者其他函数中)`，不能出现在循环、判断或者try/catch/finally以及with等语句中；函数表示式在这方面没有约束

      ```js
      //不要这样做！
      if(condition){
        function sayHi(){
          alert("Hi!");
        }
      } else {
        function sayHi(){
          alert("Yo!");
        }
      }
    ```

## 8.2 函数调用

> 函数调用有4种方式：
>
> - 作为函数 `this==window`
> - 作为方法 `this==调用对象`
> - 作为构造函数 `this==新建对象`
> - 通过call()和apply()Function.prototype方法间接调用 `this==方法参数`

### 8.2.1 函数调用

1. 如果一个函数是一个属性访问表达式进行的调用，那么它就是方法调用，否则就是函数调用
2. 会先计算参数表达式的值，
3. 函数调用的this调用上下文指的是全局对象window，在严格模式下为undefined；通过这条规则可以用来判断当前脚本是不是执行在严格模式下

### 8.2.2 方法调用

1. 方法调用说白了就是通过对象属性调用函数，与函数调用的最大区别就在于this调用上下文的指向
2. 通过方法调用的函数会隐式的传入一个实参对象`(可以通过this访问)`，这个实参对象指向方法的附着对象；通过这种机制可以很明确的表明函数将会基于此对象进行操作
3. 嵌套函数中的this和包含函数的this不是一回事，想在嵌套函数中访问包含函数的this则必须先将this赋值给局部变量`(this是一个关键字，不是变量，不允许给this赋值)`

### 8.2.3 构造函数的调用

1. 如果函数或者方法调用之前存在关键字new，那么就会构成构造函数的调用
2. 如果构造函数没有形参，那么JavaScript语法允许省略圆括号
3. 构造函数调用会创建一个对象，然后这个对象的`__proto__`将会从构造函数的`prototype`继承；创建的对象会作为该函数的调用上下文this，构造函数可以通过this进行相应的初始化操作
4. 构造函数可以不使用return语句，因为构造函数一般用于初始化新对象，最后会自动的返回初始化的对象；如果说return返回了一个对象，那么就会返回此对象，否则return没有指定返回值`(undefined)`或者返回的是一个原始值，那么将会忽略该返回值并返回初始化的新对象`this`

### 8.2.4 间接调用

通过call和apply方法来进行函数的间接调用，这两个方法都可以指定函数的调用上下文this

## 8.3 函数的形参和实参

> 函数调用不会对传入的任何实参做类型检测，也不会检测传入实参的个数，所以传入参数的检测和处理都需要自己来书写

### 8.3.1 可选参数

1. 当实参比形参少时，剩余的形参设置为undefined，这是应该考虑给形参一个比较合理的默认值（换句话说形参个数是不一定的）
2. 可选形参应该放在形参列表的最后

### 8.3.2 可变长的实参列表：实参对象arguments

1. 当实参个数多余形参个数时，可以通过arguments来访问实参列表对象；arguments是一个类数组对象可以通过下标来访问实参值而不必通过形参名访问，可以通过arguments.length来访问实参的个数
2. arguments最适合实参个数不确定的场景
3. arguments中的元素相当于函数形参的一个别名，所以它们指向的是同一个值，修改其中一个会改变另一个`（原始值和对象都是）`
4. arguments.callee属性指向当前执行的函数；caller已经废除（指向调用当前函数的函数）

### 8.3.3 将对象属性作为参数

> 记住函数的参数顺序很麻烦，此时可以将实参写入一个对象，通过传入此对象作为参数

### 8.3.4 实参类型

> JavaScript方法的形参没有类型声明，形参传入函数体之前也不会有任何的类型检查，所以需要自己写逻辑进行判断；不过这种灵活的弱类型语言有时也适合编写参数类型和个数不确定的函数

## 8.4 作为值的函数

> 函数也是对象，可以赋值给变量，存储在对象的属性或者数组的元素中，还可以作为参数传入函数中，比如Array.prototype.sort()方法；同时也可以为函数定义自己的属性

## 8.5 作为命名空间的函数-执行匿名函数

> 函数中的变量在函数体内是可见的，在函数体外是不可见的；不在任何函数内声明的变量都是全局变量（函数体内没有使用var声明的变量也是全局变量）；为了防止污染全局命名空间，可以执行匿名函数

```js
(function(){
  //  模块代码
}());
```

## 8.6 闭包

### 8.6.1 闭包基础

1. 一般来说一个函数内嵌套了另一个函数，然后返回这个嵌套的函数时就会产生闭包
2. 非闭包时，在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的`[[Scope]]`属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的`[[Scope]]`属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象(compare的局部变量们)被创建并被推入执行环境作用域链的前端。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域`[[Scope]]`（全局执行环境的变量对象）。但是，闭包的情况又有所不同。

    ```js
    function compare(value1, value2){
      if (value1 < value2){
        return -1;
      } else if (value1 > value2){
        return 1;
      } else {
        return 0;
      }
    }
    var result = compare(5, 10);
    ```

    ![7-1](/blog/images/js/7-1.png)

3. 当定义内部函数的时候，会为内部函数创建一个包含外部函数活动对象的作用域链，这个作用域链将会保存在内部函数的`[[Scope]]`属性中；当执行内部函数的时候，会为内部函数创建一个执行环境，并复制`[[Scope]]`属性到执行环境的作用域链中；此后还会创建一个内部函数的活动对象保存用于自己的内部变量，并将活动对象放入执行环境作用域链的顶端；每一次函数的执行都会创造执行环境和销毁执行环境，但是执行环境的作用域链(活动对象)是可以在执行环境销毁以后被别的引用保存下来的，比如闭包中内部函数的`[[Scope]]`；通过将内部函数设置为等于null解除该函数的引用，可以通知垃圾回收例程将其清除，随着匿名函数的作用域链被销毁，活动对象们（除了全局作用域）才会销毁

    ```js
    //创建函数
    var compareNames = createComparisonFunction("name");
    //调用函数
    var result = compareNames({ name: "Nicholas" }, { name: "Greg" });
    //解除对匿名函数的引用（以便释放内存）
    compareNames = null;
    ```

    ![7-2](/blog/images/js/7-2.png)

4. 可以使用闭包中的局部变量（传入的参数）来定义私有变量，返回的函数可以是getter和setter属性函数
5. 内部函数是无法通过this和arguments访问外部函数的this和arguments的，必须将这两个值先赋值给变量才行

### 8.6.2 闭包与自变量

```js
function createFunctions(){
  var result = new Array();
  for (var i=0; i < 10; i++){
    result[i] = function(){
      return i; /* 都使用同一个变量i */
    };
  }
  return result; /* result中的每个函数都返回10 */
}

function createFunctions(){
  var result = new Array();
  for (var i=0; i < 10; i++){
    result[i] = function(num){
      /* 创建了10个新的变量num */
      return function(){
        return num;
      };
    }(i);
  }
  return result; /* result中的每个函数返回值不一样 */
}
```

## 8.7 函数属性、方法和构造函数

### 8.7.1 length属性

> 函数的length属性表示的是定义函数时形参的个数；argument.length表示的是实参的个数

### 8.7.2 prototype属性

每一个函数在被定义时都会创建一个prototype属性，这个属性指向函数的原型对象；使用该函数构造出来的对象会将其`__proto__`属性指向该原型对象，从而实现继承

### 8.7.3 call方法和apply方法

1. call和apply方法都可以用来间接地调用函数，也就是说可以改变函数执行时的调用上下文this对象
2. 严格模式下call和apply的第一个实参都会当做this的值，且可以是原始值或者是undefined和null；非严格模式下null和undefined会被全局对象替换，原始值会转化为相应的包装对象
3. call：第一个参数表示调用上下文this，之后的所有实参代表要传入代调用函数的值；apply：与call的相比，第一个参数一样都指this，但是第二个参数是一个类数组或者真实数组对象，包含传入调用函数的实参

### 8.7.4 bind()方法

1. 调用bind方法可以将传入的参数与调用该方法的函数绑定在一起，并返回一个新的函数；第一个参数绑定this对象，后面的参数按照顺序绑定至调用函数的实参上

    ```js
    var sum = function(x, y){return x+y;}
    var succ = sum.bind(null, 1);
    succ(2) = 3 //x绑定为1， 2传给
    function f(y, z) {return this.x+y+z;}
    var g = f.bind({x:1}, 2);
    g(3) //6 this.x绑定1 y绑定2 z绑定3
    ```

2. bind返回函数的length值等于调用bind方法的函数的形参个数减去本次bind方法绑定的实参个数；返回函数可以用做构造函数，此时忽略bind方法传入的this值；返回函数没有prototype属性，所以作为构造函数时使用原始未绑定的函数的prototype；对于instanceof运算，返回函数也采用原始未绑定函数的类作为判断依据

### 8.7.5 toString（）方法

1. 大多数函数的toString方法会返回函数的完成代码，但是内置函数往往返回"[native code]"，因为它们的代码往往可能是C++实现的

### 8.7.6 Function()构造函数

1. 可以使用Function构造函数来创建函数对象；其实所有的函数都会继承至Function.prototype对象
2. new Function()中传入任意数量的字符串，最后一个实参文本表示函数体，前面的实参字符串指定函数的形参名；不需要传入函数名，所以该方式`只能创建匿名函数`
3. Funciton是在JavaScript运行时动态的编译其内部函数，循环中每次都会重新编译，影响效率
4. Function中函数代码的编译总是在全局作用域中进行的，所以不能产生闭包（功能相当受限）

### 8.7.7 可调用的对象

  > JavaScript中有些对象也是可以调用的，通过`()` 比如说RegExp可以直接调用正则对象来代替exec()方法的调用，不过可调用对象更多的被函数所替换了；typeof不能很好地在所有浏览器中区分函数与可调用对象，这时可以通过判断class属性是不是Function来区分(Object.prototype.toString)

## 8.8 函数式编程

JavaScript可以向操作对象一样操作函数，也就衍生出了函数式编程技术

### 8.8.1

> 这些方法在数组章节进行了详细说明的，大致就是通过将函数对象作为参数传入别的函数，然后在别的函数中通过call apply来调用该函数对象的技巧

### 8.8.2 高阶函数

> 所谓高阶函数就是操作函数的函数，它接受一个或多个函数，并最终返回一个新函数

### 8.8.3 不完全函数

> 也是一种函数变化的技巧，把完整的函数调用分为多次函数调用，每次传入的参数都是完成实参的一部分，每个拆分的函数就叫做不完全函数，比如`f(1,2,3,4)拆分为f(1,2)(3,4)`

### 8.8.4 记忆

> 通过闭包或者函数属性的方式将函数调用的结果保存下来，已达到空间换时间，增加程序执行效率的技巧
