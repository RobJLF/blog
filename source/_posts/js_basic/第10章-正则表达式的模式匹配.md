---
title: 犀牛-第10章-RegExp类型
permalink: RegExp
date: "2018/11/12"
mathjax: true
tags: 
- JS 
- RegExp
- 犀牛书
categories: JS
---

# 第10章-正则表达式的模式匹配

1. JavaScript的正则表达式语法是Perl5正则表达式语法的一个大型子集
2. String和RegExp都定义了有关正则表达式的方法

## 1 正则表达式的定义

1. 可以使用`构造函数`或者`直接量`来生成正则表达式对象

    ```JavaScript
    var pattern = new RegExp("s$");
    var patter = /s$/;
    ```

2. `直接量`每次返回一个新对象
3. 正则表达式中多数的字符都是按字面量匹配，还有一些具有特殊语义

### 1.1 直接量字符`(字面量字符|单字符)`

1. 所有的`字母`和`数字`都是按照字面量进行匹配的，同时还有一部本字符匹配需要通过`\`进行转义

    ```javascript
    \o NUL字符(\u0000)
    \t 制表符(\u0009)
    \n 换行符(\u000A)
    \v 垂直制表符(\u000B)
    \f 换页符(\u000C)
    \r 回车符(\u000C)
    \xnn 16进制数nn指定的拉丁符号 \x0A等价\n
    \uxxxx 16进制数xxxx指定的Unicode字符
    \cX 控制字符^X,\cJ===\n
    ```

2. 在正则表达式中许多的`符号`都有特殊的含义，它们是`^ $ . * + ? = ! | \ / () [] {}`，如果想用这些符号的直接量进行匹配，需要在前面添加`\`，包括反斜线自己 `/\\/匹配反斜线`，这是一条通行规则。其他没有特殊意义的标点符号按照字面量匹配  
3. 如果不记得哪些`符号`需要反斜杠来转义为字面量，可以在所有`符号`前面都加上反斜线；许多`数字和字母`在反斜线转义时有`特殊含义`，所以对于按直接量进行匹配的`数字和字母`，不要使用反斜杠

### 1.2 字符类`(单字符集合)`

1. 将任意个`直接量字符`放在方括号`[]`内就成为了字符类，字符类可以匹配其所包含的`直接量字符`;另外通过在字符类最左边加入`^`可以定义`否定字符类`；字符类还可以用连字符`-`定义字符范围

    ```javascript
    [abc] //可以和"a" "b" "c"中的任意一个匹配
    [^abc] //可以和"a" "b" "c"以外的任意一个匹配
    ```

2. 特殊的`单字符集合`

    ```javascript
    [...]  方括号内的任意字符
    [^...]  不在方括号内的任意字符
    .  除去换行符和其他Unicode行终止符之外的任意字符
    \w  任何ASCII字符组成的单词，等价于[a-zA-Z0-9_] 字母数字下划线
    \W  任何非ASCII字符组成的单词，等价于[^a-zA-Z0-9_]
    \s  任何Unicode空白符
    \S  任何非Unicode空白符
    \d  任何ASCII数字，等价于[0-9]
    \D  任何非ASCII数字，等价于[^0-9]
    [\b]  退格直接量(特例)
    ```

### 1.3 重复

1. 语法

    ```javascript
    {n, m}  匹配前一项至少n次，但是不能超过m次
    {n,}    匹配前一项n次或者更多次
    {n}     匹配前一项n次
    ?       匹配前一项0次或者1次, {0,1}
    +       匹配前一项1次或者更多次, {1}
    *       匹配前一项0次货值更多次, {0}

    /a*/和字符串"bbbb"是匹配的，因为这个字符串含有0个a
    ```

2. **费贪婪的重复**  
    > 上表中的重复匹配是一种贪婪的匹配方法，也就是说匹配重复字符是尽可能多地匹配`（即使已经匹配成功了还是会继续往下匹配）`。同时我们也可做非贪婪的匹配，只需要在这些重复符号后面添加一个问号即可：`??  +?  *?  {1,5}?等`比如说`/a+/`会匹配`"aaa"`字符串的三个字符；而`/a+?/`只会匹配`"aaa"`字符串的第一个`a`。
3. **从左往右的匹配**
    > 正则表达式的模式匹配是从左往右匹配的，比如说`/a+?b/`和`"aaab"`匹配的话会匹配真个`"aaab"`字符串，而不只是单单最后两个字符`"ab"`

### 1.4 选择项、子表达式分组和子表达式引用

> 正则表达式还包括指定选择项、子表达式分组和引用前一个子表达式的特殊字符。

1. 选择项 `使用|定义选择项`
    > 选择项中`/ab|cd|ef/`可以匹配字符串`"ab"` `"cd"` `"ef"`；`/\d{3}|[a-z]{4}/`匹配的是三位数字或者四个小写字母。  
    >  选择项的匹配次序从左到右，直到发现了匹配项为止，也就是说左边的匹配项的优先级是高于右边的匹配项的，比如`/a|ab/`匹配字符串`ab`只会匹配第一个字符`"a"`
2. 子表达式 `使用()定义子表达式`
    > 正则表达式中的圆括号有许多的作用，第一个就是把单独的项组合成子表达式，以便可以像处理一个独立的单元一样用`| * + ?`等符号对整个子表达式使用。  
    > 圆括号的第二个作用是在完整的模式中定义子模式。当一个正则表达式和目标字符串匹配时，可以从目标字符串中抽出和圆括号中的子模式相匹配的部分。（后面说明具体方法的时候会讲到）
3. 子表达式的引用`(使用\数字定义)`
    > 圆括号还允许在同一个正则表达式的后部分引用前面的子表达式，通过`\后面添加数字`来实现。这个数字指定了带圆括号的子表达式在正则表达式中的位置。因为子表达式之间是可以嵌套的，所以子表达式的位置其实是以左括号的位置来计算的。  
    > 对正则表达式前一个子表达式的引用不是指对子表达式模式的引用，而是指匹配成功后对匹配的那段文本的引用`(引用文本而非模式)`。

    ```javascript
    reg = /['"][^'"]*['"]/  不要求左侧和右侧的引号类型相同
    reg = /(['"])[^'"]*\1/    要求左右两侧的引号类型相同
    ```

    > 子表达式引用不能用在方括号也就是字符类中

    ```javascript
    reg = /(['"])[^\1]*\1/  这种写法是非法的
    ```

    > 通过`(?:  )`的方式也可以用于子表达式分组，但是只能用于分组，不能通过`\数字`进行引用，下标计数时会跳过这种分组

    ```javascirpt
    |        选择，匹配左边的子表达式或者右边的子表达式
    (...)    组合，将几个项组合为一个单元，这个单元可以通过符号加以修饰，而且可以记忆与该组合相匹配的字符串以供后面的引用调用
    (?:...)  只组合，不记忆与该组合相匹配的字符
    \n       第n个分组第一次匹配的字符串
    ```

### 1.5 指定匹配位置

某些正则表达式语法不匹配某个字符，而是指定合法的位置。

```javascript
^  匹配字符串的开头，在多行检索中，匹配一行的开头
$  匹配字符串的结尾，在多行检索中，匹配一行的结尾
\b 匹配一个单词的边界，简言之，就是位于字符\w和\W之间的位置，或者位于\w和字符串开头和结尾的位置([\b]匹配的退格符)
\B 匹配非单词边界的位置
(?=p) 零宽正向先行断言，要求接下来的字符都要与p匹配,但匹配字符串不会包括匹配p的那些字符
(?!p) 零宽负向先行断言，要求接下来的字符不与p匹配
```

### 1.6 修饰符

```javascript
i  不区分大小写
g  执行一个全局匹配，找到所有的匹配项，而不只是第一个
m  多行匹配，^会匹配一行的的开头和字符串的开头，$匹配一行的结尾和字符串的结尾
```

## 2 String中的模式匹配方法

这些方法在单独的写在了String类型章节中

## 3 RegExp对象

1. RegExp构造函数：可以有两个字符串参数(第二个可选)
    > 第一个参数是正则表达式的主体部分，也就是正则表达式直接量反斜杠之间的内容；注意此时的反斜杠`\`在字符串中应该写为`"\\"`  
    > 第二个参数是可选的，用于指定修饰符。只能传入g、i、m的组合
2. 构造函数的优点就在于可以动态的创建正则表达式, 缺点是`\`的字符串转义问题

### 3.1 RegExp实例的属性

```javascript
source  一个只读的字符串，包含正则表达式的文本
global  只读的布尔值，表示是否有修饰符g
ignoreCase  只读的布尔值，表示是否有修饰符i
multiline  只读的布尔值，表示是否有修饰符m
lastIndex  可写/读的整数，如果匹配模式有g修饰符，此属性表示下一次检索的开始位置 会在exec()和test()方法中使用到
```

### 3.2 RegExp的方法

#### exec

1. exec()方法和String的match()方法很像，只不过参数是一个字符串，会在字符串中执行匹配检查，如果没有任何匹配，返回null；找到了匹配就返回一个数组。
2. 数组第一个元素是正则表达式的匹配字符串，余下的数组元素是与圆括号内的子表达式相匹配的子串；数组的属性index包含了发生匹配的字符位置，属性input指向正在检索的字符串
3. 和match不同的是，无论是否是全局匹配模式p，exec总是返回一个匹配结果，并提供本次匹配完整的信息。不过当有g时，lastIndex属性会发生改变，当匹配时会把lastIndex设置为匹配字符串的末尾位置+1，如果某次查询没有发现任何匹配项时，lastIndex重置为0(一般都是最后一次了，切记开始新的字符串查找前都应将lastIndex设置为0)

#### test

1. test方法更为简单，它的参数是一个字符串，如果匹配成功，返回true，相当于exec结果不是null则返回true
2. test也会像exec一样，在全局匹配模式p时改变lastIndex的值
