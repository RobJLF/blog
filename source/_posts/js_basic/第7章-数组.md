---
title: 犀牛-第7章-数组类型
permalink: Array
date: "2019/7/17"
mathjax: true
tags: 
- JS 
- Array
- 犀牛书
categories: JS
---

## 第7章-数组

1. 数组的元素可以是任意类型的
2. JavaScript数组的索引是基于0的32位数值：第一个元素索引为0，最大索引为(2^32-2)
3. JavaScript数组是动态的：根据需求会自动增长或者缩短
4. JavaScript数组是可稀疏的：数组元素的下标索引可以不是连续的
5. JavaScript数组是对象的特殊形式，数组索引和碰巧是整数的属性名差不多，不过数组的实现经过优化，使用数值索引更快。

## 7.1 创建数组

``` javascript
1.直接量
var empty = [];
var misc = [1.1, true, [], {}];
直接量中的值可以是任意表达式

省略直接量的某个值，省略的元素被赋值为undefined（准确来说应该是empty slot）；最后一个逗号是可选的
var count=[1,,3];
var undefs=[,,];  //两个元素 不是三个

2.构造函数
无参数
var a = new Array() //等同于[]
一个数值参数
var a = new Array(100) //指定长度length 此时数组中还没有存储值，甚至数组索引属性"0","1"都还没有创建
多个参数或一个非数值参数
var a = new Array(5, 6, "test"); //使用字面量更加方便
```

## 7.2 数组元素的读和写

1. 使用`[]`中加入返回非负数表达式的方式来实现对数组元素进行读写。
2. 数组是对象的特殊形式，所以使用方括号访问数组元素和使用方括号访问对象属性其实是一样的。JavaScript会把指定的数值索引转换为字符串，比如说`a[1]==a["1"]`
3. 数组的特别之处在于：使用合法范围内的非负整数作为属性名时数组会自动的维护它的length属性值。
4. 所有的索引都是属性名，但只有`0~2^32-2`范围内的属性名才是索引；非负整数的字符串`"1"`和整数大小的浮点数`1.000`都会作为数组索引。

    ```javascript
    a[-1.23] = true;//创建一个名为"-1.23"的属性
    a["1001"] = 0; //数组第1001各元素为0
    a[1.000] = 0; //数组第一个元素为0
    ```

5. 数组可以定义和继承getter和setter属性

## 7.3 稀疏数组

1. 稀疏数组就是指索引下标不连续的数组，其length大于数组元素个数。

    ```javascript
    以下情况都是稀疏数组
    a = new Array(5);//length=5(5个empty slot) 没有属性 0 in a返回false
    a = [1000];//0 in a返回false
    a = [,,,]; //length = 3(3个empty slot) 但是没有属性 0 in a返回false
    a = []; arr.length=3; //(3个empty slot)
    a = []; arr[3] = 1; //(3个empty slot 一个1)
    ```

2. 稀疏数组不是某下标属性值是undefined而是说属性不存在

    ```javascript
    [1,,3](稀疏)不等于[1,undefined,3](不稀疏)
    ```

3. delete删除属性也会造成稀疏数组

## 7.4 数组长度 **length**

1. 数组的length属性使其区别于常规的JavaScript对象。对于非稀疏数组，length属性值就等于数组中元素的个数。
2. 数组的length等于数组元素max下标值+1
3. 所以为数组元素赋值时`例：arr[i] = item`，如果该元素下标志i大于当前length，那么length会刷新为i+1
4. 如果给length赋值一个小于当前长度的非负整数n，那么所有索引值大于等于n的元素将会从数组中删除
5. 如果给length赋值一个过大的值，那么会产生稀疏数组，实际上不会增加新的属性，只会增加empty slot

## 7.5 数组元素的添加和删除

1. `添加`数组元素

   - 为新的索引处的元素赋值`例：arr[i] = item`
   - 使用push方法在数组末尾增加一个或多个元素

    ```javascript
    a.push('j');
    a.push('g', 'g');
    该方式给数组添加元素等同于给`a[a.length]`赋值。
    可以使用`unshift()`在数组的首部插入一个元素，同时使所有的其他元素分别往后挪动一位
    ```

2. `删除`数组元素

- 使用delete运算符，相当于将某个元素设置为empty slot，所以length的值不会改变，同时会产生稀疏数组
- 设置length来删除数组元素
- 使用pop()`push`和shift()`unshift`方法，相比于delete运算符，这两个方法会改变length的值，如果对应删除的数组元素是empty slot那么会删除这个empty slot并返回一个undefined
- 通过splice()方法来插入、删除和替换数组元素(7.8)

## 7.6 数组遍历`即遍历索引属性`

1. 使用length属性配合for循环遍历，稀疏数组注意手动排除empty slot
2. 使用for/in循环，首先会遍历继承属性，且会有非索引属性出现，其次遍历顺序不一定是升序的， 不合适
3. 使用ES5新定义的Array.prototype.forEach()方法, `data.forEach(function(x){})`按照索引的顺序依次将值传递给指定的函数，且内部排除了empty slot，继承属性和非索引属性

## 7.7 多维数组

> JavaScript并不支持多维数组，不过可以通过数组的数组来近似

## 7.8 数组的方法

> ES在Array.prototype中定义了许多操作数组的函数

### 7.8.1 join()

1. 将数组中所有的元素都先转化为字符串，连接后返回最终生成的字符串。`empty slot ,undefined ,null` 都转化为`""`

2. 可以制定一个可选的字符串作为分隔符，不指定默认使用逗号分隔

    ```javascript
    var a = [1,2,3];
    a.join(); //"1,2,3"
    a.join(" "); //"1 2 3"
    ```

3. Array.join()方法是String.split()方法的逆向操作，后者将字符串通过自定字符串分隔为数组

### 7.8.2 reverse()（影响调用数组）

颠倒使用方法的数组，并返回颠倒后的数组。empty slot会被翻转

### 7.8.3 sort()（从左到右递增）(影响调用数组)

1. 不带参数时，以字母表的顺序排列数组元素(除开undefined、empty之外都转化为字符串)；如果包含undefined元素，它会排到数组尾部，且在empty plot之前；empty plot排在尾部
2. 向sort()中传入一个比较函数，该函数传入数组的中两个元素作为参数，结果返回数字；如果返回正数，表示左边的值比右边的大，返回负数表示左边的值比右边的小，返回0表示两边的值想等；数组中的undefined元素使用排在数组末尾，不会被传递给比较函数进行比较（empty slot也一样）；比较思路有点像冒泡；最好传入一个匿名函数

### 7.8.4 concat()(不影响调用数组)

1. 返回一个新的数组，元素包括原数组和concat()方法中的每个参数。
2. 如果这些参数本身就是数组，那么会扁平化数组参数，但是不会递归扁平化

### 7.8.5 slice()（不修改调用数组）

1. 可以指定两个参数，分别指定了开始和结束的位置（左开右闭`[)`）
2. 如果只有一个参数，则一直截取到数组末尾
3. 如果参数中出现了负数，则表示相对于数组末尾元素的位置(-1表示最后一个元素，-2表示最后第二个)
4. 如果左参数对应数组索引在右参数的右边，那么会返回空数组

### 7.8.6 splice()(修改调用数组)

1. 在数组中插入或删除元素的通用方法，插入和删除会修改索引使元素下标仍然保持连续，返回删除元素数组。
2. 第一个参数指定插入和删除元素的起始位置，第二个参数指定了应该删除的元素个数，如果省略第二个参数，那么将一直删除到数组末尾。
3. 如果说已经指定了两个参数，那么紧随其后的任意个数的参数会插入到数组中，从第一个参数指定的位置插入；不会对插入的数组元素进行扁平化

### 7.8.7 push()和pop()（修改调用数组）

1. push在数组的`尾部`加入一个或者多个元素，并返回新数组的长度；pop删除数组的最后一个元素，减小数组的长度，并返回被删除的元素；类似进栈出栈

### 7.8.8 unshift()和shift()(修改调用和数组)

1. unshift和shift与上面两个方法类似；在数组的`头部`进行插入和删除操作；且这两个方法都会移动下标保证元素索引的连续性

### 7.8.9 toString()和toLocaleString()（不修改调用数组）

1. toString会调用每个元素的toString()方法转为字符串，并输出逗号分隔的字符串列表，和不带参数的join方法一样
2. toLocaleString唯一的不同就是改为调用每个元素的toLocaleString方法来生成字符串然后再合成

## 7.9 ECMAScript 5中的数组方法

1. ECMAScript5定义了9个新的数组方法用来遍历、映射、过滤、检测、简化和搜索数组
2. 大多数数组方法的第一个参数接受一个函数，并且对数组的每一个元素调用一次该函数；如果是稀疏数组，对不存在的empty slot元素不会调用该函数
    > 虽然empty slot不会调用内嵌函数，但是同for循环一样，empty slot是会传入到数组方法中的，只是数组方法帮我们过滤了empty slot，导致其不会调用内嵌函数
3. 调用的函数一般使用三个参数：本次的数组元素，本次的元素索引、数组本身（一般都只需要第一个参数）
4. 数组方法的第二个参数(可选)是作为调用函数的this关键字上下文的
    > 非索引（自然数）属性和继承属性也不会调用该函数

### 7.9.1 forEach()

1. forEach()从头到尾遍历数组元素，为每个元素调用指定的函数。
2. forEach第一个参数表示调用函数，第二个参数表示调用函数的this值；调用函数可以有三个参数:数组元素，元素索引，数组本身(一般情况下只需要第一个就够了)

    ```javascript
    var data = [1,2,3,4,5];
    var sum = 0;
    data.forEach(fucntion(value){sum+=value});
    sum //15
    data.forEach(funciton(v, i, a){a[i] = v + 1})
    data[2,3,4,5,6]
    ```

3. forEach无法在所有元素都传递给调用函数之前结束，也就是说它无法像for循环那样通过break语句提前结束循环。如果想要提前结束forEach，需要手动抛出异常，如下try/catch抛出foreach.break异常，这样循环才会提前结束

    ```javascript
    function foreach(a,f,t) {
    try{a.foreach(f,t)}
    catch(e) {
        if(e === foreach.break) return;
        else throw e;
        }
    }
    foreach.break = new Error("StopIteration");
    ```

4. forEach是没有返回值的，返回值为undefined

### 7.9.2 map()

1. map()方法的参数结构和forEach一样
2. map方法将每个数组元素传递给map中的函数，返回一个和原数组的length相等数组

    ```javascript
    a = [1,2,3];
    b = a.map(function(x){return x*x}); //b=[1,4,9]
    ```

3. 传递给map的函数应该具有返回值，这样map就会将该值放入将要返回的数组中（如果没有返回值返回undefined）；对于稀疏数组中的empty slot，map方法将返回empty slot（不会传入调用函数中，会在map函数中直接返回），所以返回的也是相同的稀疏数组，它们具有相同的长度和缺失元素

### 7.9.3 filter()

1. filter方法的调用参数同forEach一样
2. filter方法会返回一个数组，且该数组是调用数组的一个子集

    ```javascript
    a = [5,4,3,2,1];
    smallvalues = a.filter(function(x){return x<3;}); //[2,1]
    ```

3. filter函数应该返回true或者false（准确来说是真值和假值），如果是真值那么对应的数组元素就会被添加到子集中，否则为假值不添加
4. filter会默认的跳过empty slot元素，所以返回的数组总是稠密的

    ```javascript
    为了压缩稀疏的数组
    var dense = sparse.filter(function(){return true;});
    ```

### 7.9.4 every()和some()

1. every()和some()方法是对数组的逻辑判断，并最终放回true或者false
2. every：当对所有的数组元素（除去empty slot）调用函数返回真值，every才会返回true some：当存在某个数组元素（除去empty slot）调用函数返回真值，some就会返回true 这两种方法都会短路，可以提前结束执行。
3. 惯例：空数组every返回true some返回false

    ```javascript
    a = [1,2,3,4,5];
    a.every(function(x){return x<10}); //true
    ```

### 7.9.5 reduce()和reduceRight()

1. 这两个方法会使用指定的函数将数组元素进行归并，最后生成一个单值；这在函数式编程中较为常见的操作，也称为注入或者折叠。

    ```javascript
    var a = [1,2,3,4,5];
    var sum = a.reduce(function(x,y){return x+y},0)//求和
    var product = a.reduce(function(x,y){return x*y},1)//数组求积
    ```

2. reduce允许两个参数，第一个参数为执行化简操作的函数；第二个参数(可选)为传递给函数的初始值`（不是内嵌函数的this指向）`
3. reduce()中内嵌函数的参数列表和前面的函数不同，第1个参数代表目前为止化简操作的累积结果，2~4位参数才是数组元素，元素索引和数组本身；第一次调用内嵌函数时，内嵌函数的第1个参数就是reduce中的第2个参数`（初始值）`，之后调用函数，第1个参数就是上一次函数调用的返回值；如果说reduce没有指定初始值，那么取数组的第1个元素作为初始值
4. 空数组，不带初始值，调用reduce导致类型错误；如果数组元素和初始值中就只有一个有值，那么调用reduce就是简单的返回该值，不会在调用化简函数
5. reduceRight和reduce本质上一样，只是执行顺序是从数组的尾部开始的
6. 更多的例子看书吧

### 7.9.6 indexOf()和lastIndexOf()

1. 这两个方法用于搜索整个数组中具有给定值的元素，并返回找到的第一个元素的索引，没有找到返回-1；indexOf从头开始找，lastIndexOf反向搜索
2. 这两个方法不接受函数作为参数，第一个参数是需要搜索的值，第二个参数(可选)指定一个索引表示搜索的起点，可以是负数(和splice方法一样 -1指定最后一个数组元素)

## 7.10 数组类型

1. 使用Array.isArray()来判断一个对象是不是数组`（内部实现使用Object.prototype.toString）`
2. 使用`a instanceof Array`来判断对象是不是数组也不可靠，因为不同窗口中都会有自己的Array对象，那么就算是Array对象但是原型链还是可能接不上

## 7.11 类数组对象

1. JavaScript数组对象的一些特性是其他对象所没有的
   - 当新的元素添加到数组中时，自动更新length属性
   - 设置length的值可以截断数组
   - 从Array.prototype中继承方法，类属性为Array
2. 这些特性让JavaScript数组区别于其他对象，但是他们不是定义数组的本质特性；一种合理的看法是：`拥有length作为属性名(number类型)和自然数作为属性名的对象可以看做"类数组"`
3. DOM中如document.getElementsByTagNames()也返回类数组对象
4. JavaScript的数组方法是特意定义为通用的，因此它们不仅可以在真正的数组上使用，在类数组上也能正确的工作，使用Function.call方法来调用这些Array.prototype上的方法。最好只用只读的或者至少保持数组长度不变的方法，否则可能导致length值和索引属性数量不相等
    > 本质上数组方法的实现是在length字段的范围内通过for循环遍历索引属性
5. 更多举例看书

## 7.12 字符串作为类数组

1. 字符串的行为类似只读的数组，除了可以使用charAt()来访问单个的字符外，还可以使用方括号

    ```javascript
    var s = 'test';
    s.charAt(0) //"t"
    s[0] //"t"
    s[0] = 1//赋值无效果
    ```

2. 通用的数组方法也是可以用在字符串上
3. 字符串是不可变值，故把它当做数组看时是只读的。如push、sort、reverse和splice等数组方法会修改数组，但是对字符串是无效的。不仅如此使用数组方法修改字符串会导致错误，而且出错时不会有提示。
