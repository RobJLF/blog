---
title: 犀牛-第3章-类型、值和变量
permalink: 类型、值和变量
date: "2019/7/13"
mathjax: true
tags: 
- JS
- 犀牛书
categories: JS
---

## 第3章-类型、值和变量

>计算机程序的运行需要对值进行操作。能够表示并被操作的值的类型称为数据类型。

JavaScript的数据类型分为两类：原始类型(primitive type)和对象类型(object type)。其中原始类型包括：数字、字符串、布尔值、null和undefined。对象类型就是属性的集合，JS中重要的对象类型有：数组、函数、类（构造函数）、日期、正则类、错误。

JS有自己的内存管理机制，有点像JAVA的GC，自动清理没有引用的对象。

JavaScript的类型还可以分为拥有方法的类型和没有方法的类型，可变类型和不可变类型。

## 3.1数字

JavaScript的数字不区分整数和浮点数，所有的数字在内部均是使用ieee-754标准的64位浮点数格式进行表示。
小数范围：最大值$\pm 1.79769 \times10^{308}$ 最小值:$\pm 5 \times10^{-324}$
整数范围：$\pm 2^{53}$ 如果超过了则无法保证精度
但是JavaScript中实际的整数操作是基于32位整数。

当一个数字直接出现在程序中时，我们称为数字直接量。

## 3.1.1整数直接量

除了使用10进制外，还可以使用16(0x或0X)进制 但是某些引擎不支持8进制。且严格模式下8进制是禁止的。

## 3.1.2浮点型直接量

浮点型直接量可以含有小数点，由整数部分和小数部分组成。此外还可以使用指数计数法（科学计数法）表示浮点型直接量`1.458e(E)-32`
简洁语法：`[digits][.digits][(E|e)(+|-)]digits`

## 3.1.3算数运算

`+ - * / %等`更多的运算方法参考Math对象。数字特数量有`+-Infinity、+-0、NaN`

```js
Infinity===Number.POSITIVE_INFINITY===1/0===Number.MAX_VALUE+1
-Infinity===-1/0===-Number.MAX_VALUE-1
NaN=Number.NaN===0/0
-0===-Number.MIN_VALUE/2===-1/Infinity===0

切记：NaN不与任何相等，包括自己，所以与自己不相等的值便是NaN，函数isNaN()的原理类似。
```

## 3.1.4二进制浮点数和四舍五入

根据ieee-754浮点数的存储方式，JavaScript中的浮点数很多时候都是一个近似值，会与理想的计算值存在偏差。

## 3.1.5日期和时间

Date()构造函数用于创建表示日期和时间的对象。更多细节这里不谈。

## 3.2文本（字符串）

字符串本质上是由16位值组成的不可变的有序序列。

- 索引从0开始
- 没有char的单字符数据类型
- 采用UTF-16编码方式存储Unicode内码

## 3.2.1字符串直接量

字符串直接量由单引号或者双引号括起来的字符序列

- 单引号中可以包含双引号；双引号中可以包含单引号。
- ES3中字符序列必须写在同一行上，ES5中可以通过反斜线(\)进行换行，但是反斜线和行结束符都不属于直接量的内容
- 可以使用转义字符\n在直接量中表示换行

## 3.2.2转义字符

在JavaScript字符串中，反斜线有着特殊的用途，在反斜线后面加上一个字符可以表示别的字面意义。（转义）

```js
\n \o \b \" \' \\
\xXX(两位16进制的Latin-1字符)
\uXXXX(4位16进制的Unicode字符)
```

如果反斜杠后面没有使用规定的字符，则会忽略反斜线。比如'\\#'='#'

## 3.2.3字符串的使用

- 使用`+`进行字符串连接
- 使用length属性得到16位值的个数(不是字符个数)
- 此外还用很多可调用的方法

```js
var s = "hello,world"
s.chatAt(0)
s.charAt(s.length-1)
···更多例子看书，或者查看资料
```

无论执行什么方法，字符串中的值都是不变的。比如说replace()和toUpperCase()的方法都是返回新的字符串。

- 字符串也可以当做只读数组，除了使用charAt()方法，也可以使用方括号访问单个字符。`s[0]等价于s.charAt(0)`

## 3.2.4模式匹配

RegExp()构造函数，用来创建表示文本匹配模式的对象（正则表达式）。

- RegExp对象定义了很多有用的方法，同时字符串也具有接受RegExp为参数的方法。比如`text.search(pattern) text.match(pattern) text.replace(pattern, "#") text.split(pattern)`

## 3.3布尔值

布尔类型就两个值，保留字true和false。通常用在控制结构之中。

- 任何值都可以转化为布尔值。转化为false的值称为假值，转化为true的值称为真值。

## 3.4null和undefined

1.null是关键字，是一个特殊值，常用来描述“空值”。

- typeof null ==> object
- 可以表示数字、字符串、对象是“无值的”

2.undefined是预定义的全局对象，不是关键字。用来表示更深层次的“空值”。比如没有初始化的变量；不存在的属性；没有返回值的函数；没有提供实参的函数的形参的值等都将返回undefined。

- ES3的时候该对象是可读/写的，ES5改为了只读
- typeof undefined ==> undefined

3.null和undefined不包含任何属性和方法使用“.”和“[]”来存取成员和方法会返回一个类型错误。

4.undefined可能表示系统级的，出乎意料的或类似错误的空缺；而null表示程序及的，正常的意料中的空缺。如果想赋值给变量，属性或者入参，最佳选择是null。

## 3.5全局对象

这里就简单的提一下，在客户端JavaScript中（浏览器窗口中的JavaScript代码），Window对象充当着全局对象。这个Window对象有一个window属性指向自身，也可以在代码最顶端（即不在任何函数内）使用this来指向Window对象。

- 该对象定义了核心的全局属性，也针对Web浏览器和客服端JavaScript定义了少部分其他全局属性
- 初次创建时，全局对象定义了JavaScript中所有的预定义全局值。代码声明的全局变量将作为全局对象的一个属性。

## 3.6包装对象

对象是一种复合值，它是属性或已命名值的集合。通过点符号来使用属性。当属性是函数的时候，称其为方法，通过o.m()来调用o中的方法。
字符串又不是对象，那么他为什么可以调用这些方法呢?因为在引用字符串s的属性时(假比)，JavaScript会调用new String(s)的方式转换为一个临时对象，该对象继承了方法。一旦属性引用结束，这个临时对象就会销毁。

同字符串一样，数字和布尔值也有各自的包装类。null和undefined没有。

## 3.7不可变的原始值和可变的对象引用

- 原始值是不可变得，对象是可变的(有点不懂[帮助](https://www.cnblogs.com/pssp/p/5184583.html))
- 原始值的比较是值的比较，只有它们的值相等时它们才相等；对象的比较是引用地址是否相等（即引用的是否是同一个对象）

## 3.8类型转换

JavaScript取值很灵活，各种数据类型在需要时是可以相互之间进行转换的。
表3-2

| 值                    | 字符串      | 数字      | 布尔值 | 对象                  |
| :-------------------- | :---------- | :-------- | :----- | :-------------------- |
| undefined             | "undefined" | NaN       | false  | throws TypeError      |
| null                  | "null"      | 0         | false  | throws TypeError      |
| true                  | "true"      | 1         | true   | new Boolean(true)     |
| false                 | "false"     | 0         | false  | new Boolean(false)    |
| ""（空串）            | ""          | 0         | false  | new String("")        |
| "1.2"（非空，数字）   | "1.2"       | 1.2       | true   | new String("1.2")     |
| "one"（非空，非数字） | "one"       | NaN       | true   | new String("one")     |
| 0                     | "0"         | 0         | false  | new Number(0)         |
| -0                    | "0"         | -0        | false  | new Number(-0)        |
| NaN                   | "NaN"       | NaN       | false  | new Number(NaN)       |
| Infinity              | "Infinity"  | Infinity  | true   | new Number(Infinity)  |
| -Infinity             | "-Infinity" | -Infinity | true   | new Number(-Infinity) |
| 1（无穷大，非0）      | "1"         | 1         | true   | new Number(1)         |
| 对象                  | 3.8.3       | 3.8.3     | true   | 对象                  |

`Note：字符串转数字允许在开始和结尾处带有空格。但是任意非空格字符都不会被当成数字直接量的一部分，进而造成结果NaN`

## 3.8.1转换和相等性

由于JavaScript较为灵活的类型转换，因此`"=="`等可以操作多种数据类型的操作符会对两端的表达式进行多变的灵活转换(具体在下一章中进行说明解释)
比如说:

```js
null == undefined //返回true
"0" == 0 //返回true 会将字符串转化为数字
0 == false //返回true 会将false转化为数字0
"0" == false // 返回true 会将字符串和false均转化为数字0
```

4.9.1节将会详细的讲解`==`运算符

## 3.8.2显示类型转换

尽管JavaScript可自动的做许多类型转换，但是有时仍然会需要手动的进行类型转换以替换自动转换，或者为了使代码更为清晰易读。

做显示转换的方式就是通过`Boolean() Number() String() Object()`等函数实现的。当我们不使用new运算符调用这些函数时，它们会作为类型转换函数并按照3-2表所描述的规则进行类型转换。

```js
Number('3') //-->3
String(false) //-->"false"
Boolean([]) // -->true
Oject(3) //-->new Number(3)
```

- 需要注意，除了null和undefined以外的任何数据类型都是具有toString()方法的，这个方法的返回值通常来说和String()转换方法的返回结果相同。
- 如果隐性的试图把null和undefined转换为对象，会想表3-2中描述的那样，将会抛出一个类型错误的异常。当时通过Object()方法显示转换则不会抛出类型错误，它会简单的返回一个新创建的空对象。
- 开始提到过，JavaScript中某些运算符会做隐式的类型转换。比如说"+"运算符如果一个操作数是字符串，则会将另一个操作数转换为字符串；一元"+"会将操作数转换为数字；"!"会将操作数转为布尔类型并取反。

```js
+x //等价于Number(x) 也可以写为x-0
!!x //等价于Boolean(x)
```

在计算机中，数字的解析和格式化是非常普遍的工作，JavaScript提供了专门的函数和方法来更为精细的进行数字和字符串之间的相互转换。

- Number类的toString()方法可以接受转换的基数作为可选参数（不指定则默认为10进制）

```js
var n = 17;
n.toString(2) //"10001"
n.toString(8) //"021"
n.toString(16) //"0x11"
```

当处理小数和科学运算时还有以下一些方法
>toFixed()：根据小数点后的指定位数将数字转为字符串
toExponential()：使用科学计数法将数字转换为字符串，小数点前面只有一位，小数点后位数由参数指定
toPrecision()：根据指定的有效数字位数（从开头计）将数字转换成字符串，如果有效数字的位数少于数字整数部分的位数，会使用科学计数法

- 如果使用Number()将字符串转换为数字直接量，那么首先是基于10进制的，其次不能出现非法字符（不是数字）。而parseInt()和parseFloat()函数更加的灵活(它们是全局函数，不从属于任何类)。
parseInt()可以解析"0x"和"0X"前缀的为16进制数。
parseInt()和parseFloat()均忽略任意数量的前导空格，然后尽可能的解析连续的合法数字直接量，并忽略紧跟数字后的非数字内容，如果第一个非空格字符不是合法的数字直接量，那么返回NaN。

```js
parseInt("3 blinde mide") // 3
parseFloat("3.114 asdfasf") // 3.114
parseInt("0xFF") //255
parseInt("0xff") //255
parseInt("-0XFF") //-255
parseFloat(".1") //0.1
parseInt("0.1") //0
parseInt(".1") //NaN
parseFloat("$45.64") //NaN
```

parseInt()可以接受第二个参数，指定字符串数字直接量的底数，然后转换为10进制的结果，范围2-36

## 3.8.3对象转换为原始值

1.对象到布尔类型：所有的对象转换为布尔类型的结果均为true，包括new Boolean(false)
2.对象到字符串和数字：

- 所有的对象继承了两个方法一个toString()和valueOf()
- toString()作用是返回一个反应对象的字符串（实际可以返回任意值）。
- 很多类多定义了自己特定版本的toString()。比如数组类toString()方法将每个元素根据自己的规则转换为字符串，并在元素之间添加逗号合成结果字符串；函数类的toString()方法返回函数的源代码字符串；Data类型返回一个可读的日期和时间字符串；RegExp返回正则表达式的直接量的字符串。

```js
[1,2,3].toString //"1,2,3"
(function(x) {f(x);}).toString() //"function(x) {\nf(x);\n}"
/\d+/g.toString() //"/\\g+/g"
new Date(2010,1,1).toString() //"Fri Jan 01 2010 00:00:00 GMT-0800 (PST)"
```

- valueOf()方法的任务没有详细的定义，对于大多数对象，这个方法简单的返回对象本身。数组、函数、正则表达式都只是简单的继承了这个方法，调用这些类的实例的valueOf()方法只会返回对象本身。但是日期对象的valueOf()方法返回一个由1970年1月1日以来的毫秒数的数字。

3.对象到字符串转换步骤`发生在要求转换为字符串的场合（隐式或显示）`

- 如果对象有toString()方法，调用该方法。如果返回值是原始值，则将该值转换为字符串类型（表3-2）（如果原始值不是字符串的话），然后返回该字符串
- 如果对象没有toString()方法，或者该方法返回值不是原始值，那么将会调用valueOf()方法(如果存在)。如果返回值是原始值，同样的将该值转换为字符串类型（表3-2）（如果原始值不是字符串的话），然后返回该字符串
- 否则JavaScript无法从这两个方法中获得一个原始值，因此抛出类型错误异常

4.对象到数字的转化步骤`同转换为字符串步骤相同，只是调换了两个方法的次序`

- 如果对象有valueOf()方法，且返回一个原始值，将该原始值转为数字，并返回数字
- 否则，如果对象有toString()方法，且返回一个原始值，将该原始值转为数字，并返回数字
- 否则JavaScript无法从这两个方法中获得一个原始值，因此抛出类型错误异常

这也就解释了为什么空数组转换为数字的结果是0，首先调用valueOf()返回对象，舍去；然后调用toString()返回空字符串"",""转为数字便是0

5.对象转换为原始值`不会强转为数字或字符串，而是保持原始值返回`

- 大多数运算符的操作数的类型都是唯一的，比如说减号“-”要求两边都是数字，此时会隐式的将操作数转换为数字类型，对象则会调用上面的转数字的操作得到数字并返回。但是有些运算符可以操作多种类型的操作数，比如说`“+”、“==”`以及一些其他的关系运算符，此时对于对象将会使用一种有点不同的转换方式，将对象转为原始值（不会进行强制转换）
- 对于这些运算符，任何对象都是先调用valueOf()方法来尝试返回原始值，否则，再调用toString()得到原始值。切记此时日期对象Date的调用顺序的相反的。

## 3.9变量声明

在JavaScript中，使用一个变量之前应当先声明。使用关键字`“var”来声明变量。

```js
var i;
var i, sum;
var message="hello"
var i =0 , j = 0, k = 0;
```

- 如果未在var声明时初始化变量，则变量的值将是undefined。
- JavaScript是动态语言，变量的类型是可变的
- 读取一个没有声明的变量会报错`Uncaught ReferenceError: i is not defined`
- ES5严格模式下给一个没有声明的变量赋值也会报错
- ES5非严格模式下给一个没有声明的变量赋值不会报错，而是会给全局对象创建一个同名属性，工作起来很像(但不是完全一样)一个正常声明的全局属性。但不是一个好习惯，会产生bug，所以应当始终使用var声明变量，不能省略var

## 3.10变量作用域

一个变量的作用域是程序源代码中定义这个变量的区域。

- 全局变量拥有全局作用域，在JavaScript代码中的任何地方都是由定义的。
- 函数内部通过var声明的变量只能在函数体内使用。他们是局部变量，只能在函数内部使用，函数参数也是局部变量，只能在函数体内有定义。
- 在函数体内，局部变量的优先级高于同名的全局变量。

```js
var scope = "global";
funciton checkscope() {
  var scope = "local";
  return scope;
}
checkscope();//"local"

```

- 虽然全局变量可以省略var语句，但是声明局部变量时必须使用var语句，否则将会创建全局变量，如下：

```js
var scope = "global";
funciton checkscope() {
  scope = "local"; //修改了全局变量
  myscope = "local"; //创建了新的全局变量
  return [scope,myscope];
}
checkscope();//["local","local"]
scope //"local" 被修改了
myscope //"local" 多出一个全局变量 全局命名空间乱了
```

- 函数定义是可以嵌套的，每个函数都有自己的作用域，因此会出现几个局部作用域嵌套的情况。

## 3.10.1函数作用域和声明提前

在C语言中，花括号内的代码都有自己的作用域，称为块级作用域。而JavaScript没有块级作用域，取而代之的是函数作用域。可以由内向外的调用变量。

- JavaScript同级函数作用域内的变量声明和函数声明都会在当级作用域内被提前，但不涉及到声明后的赋值操作，也就是说都为undefined。该特性是在JavaScript引擎的“预编译”时执行的，在代码执行前执行。具体看这份[ppt文档](http://www.slideshare.net/lijing00333/javascript-engine)

## 作为属性的变量

当声明全局变量时其实是定义了全局对象的一个属性，当使用var声明时，创建的属性是不可配置的(6.7),也就是说该属性是无法被delete运算符删除的。在非严格模式下，不使用var创建的全局对象的属性是可配置，可以通过delete删除。

那么局部变量是否具有这种变量作为对象属性的特质呢?可以想象，局部变量当做函数调用相关的某个对象的属性，ES3中叫“调用对象”，ES5中叫“声明上下文”。但是去无法通过this来引用该对象。对我们而言是一种不可见的内部实现。具体会在之后讲解。

## 3.10.3作用域链

局部变量同级函数体内和嵌套的函数内是由定义的，这都是作用域链的功能。这个概念之后再详细介绍。
