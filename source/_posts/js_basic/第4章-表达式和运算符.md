---
title: 犀牛-第4章-表达式和运算符
permalink: 表达式和运算符
date: "2019/7/14"
mathjax: true
tags: 
- JS
- 犀牛书
categories: JS
---

## 第4章-表达式和运算符

什么是表达式呢？表达式就是JavaScript中的一个短语，JavaScript解析器会将其计算出一个结果。比如说常量就是最简单的表达式，变量名也是，复杂的表达式就是由简单表达式组成的，比如数组访问表达式可以表示为`一个数组表达式[一个整数表达式]`；同样的函数调用表达式`一个函数表达式[0个或多个参数表达式]`

将简单表达式组合成复杂表达式的最常用的方法就是使用运算符。运算符按照指定的运算规则对操作数进行计算，并返回结果值。

## 4.1原始表达式

最简单的表达式是“原始表达式”。原始表达式是表达式的最小单位-它们不能再包含其他表达式。JavaScript中原始表达式包括常量或直接量、关键字和变量。

``` js
直接量
1.23
"hello"
/pattern/

保留字
true
false
null
this//不是常量

变量
i//返回变量i的值
sum//返回变量sum的值
undefined//undefined是全局变量，和null不同，他不是关键字
```

在JavaScript中出现的标识符，JavaScript会将其当做变量去查找它的值。如果变量名不存在，会报错。

## 4.2对象和数组的初始化表达式

对象和数组的初始化表达式实际上是新创建一个对象和数组。有时称为“对象直接量”“数组直接量”。他们不是原始表达式。

``` js
数组(子表达式会进行计算)
[]
[1+2,3+4]
[[1,2,3][4,5,6][7,8,9]]

逗号之间的元素省略会填充undefined
末尾逗号不会创建一个新的undefined元素
[1,,,,5]//三个undefined
[1,,,,5,]//三个undefined

对象直接量（子表达式进行计算）
var p = {}；
var q = {x:2,y:3};
var rectangle={upperleft:{x:2,y:3},lowerRight:{x:3,y:5}}//可以是任意的JavaScript表达式

对象的属性名称可以不使用标识符，而使用字符串
var scope={"upperleft":{x:p.x,y:p.y}}
```

这里只是初步讨论，之后会在对象和数组章节进行详细的介绍。

## 4.3函数定义表达式（函数直接量）

``` js
var a=function(){}函数表达式
function b(){}函数声明语句
```

后面会详细将，自己也可以看看`潭州/08-函数.md`

## 4.4属性访问表达式

该表达式运算得到对象属性值或一个数组元素的值。有一下两中语法：

``` js
expression.identifier//对象属性的名称
expression[expression]//对象的属性或者数组的下标
```

``` js
var o={x:1,y:{z:3}}
var a={o,4,[5,6]}
o.x//1
o.y.z//3
o["x"]//1
a[1]//4
a[2]["1"]//6
a[0].x//1
```

1. 两种访问方式（.和[ ]）都是先计算其之前的表达式，如果计算结果为null或者undefined，那么抛出类型错误异常
2. 如果结果不是对象类型，JavaScript会将其转换为对象类型(3.6)。但是1不会被识别为直接量，而是会被识别为非法的标识符。
3. .符号会查找标识符指定的属性值，[]则会计算括号内的表达式并将其转换为`字符串`
4. 只要命名的属性不存在，那么整个属性访问表达式返回undefined
5. `.identifier`写法更简单，但是功能更受限：

- 访问的属性名称必须是合法的标识符(数字不当头)
- 不能是一个保留字或者包含空格和标点符号
- 不能在代码中动态生成
- 所有这些在`[expression]`中都是可行的。哈哈

## 4.5调用表达式

一种调用/执行函数或者方法的语法表现。`（返回函数对象的）函数表达式(参数)`

1. 先计算函数表达式，然后计算参数表达式得到实参。（然后实参会赋值给形参）
2. 函数表达式的值不是一个可调用的对象，则抛出一个类型错误异常（8.7.7可调用对象）
3. 如果函数表达式是属性访问表达式，那么称为方法调用，方法调用的this指向该方法的对象 （严格模式中this不指向全局对象）

## 4.6对象创建表达式

对象创建表达式通过调用一个函数(构造函数)初始化对象的属性来创建对象。对象创建表达式和函数调用表达式非常类似，但是函数调用没有new关键字：

``` js
new Object();
new Point(2,3);

如果不需要传入任何参数，那么括号可以省略
new Object;
new Date;
```

构造函数的细节查看9章

## 4.7运算符概述(哇，表达式终于完了)

1. 算术/比较/逻辑/赋值等
2. 大部分运算符由标点符号表示，有一些则由关键字表示，比如delete 和 instanceof
3. [运算符优先级](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

- 圆括号(n/a)>成员访问(L).=(L)成员访问[]=new带参数(n/a)=函数调用(L)>new无参(R)
- 单目运算符优先级比较高，且都是从右往左(R)
- `...++=...-->++...=--...`
- 具体内容看书

### 4.7.1操作数的个数

分为一元运算符(++)、二元运算符(+)、三元运算符(?:)

### 4.7.2操作数的类型和结果类型

1. 一些运算符希望操作数是指定的类型，并且返回指定的类型值。
2. 通常来说运算符会根据操作数进行类型转换(3.8)
3. 有一些运算符依赖于操作数的类型来进行不同的类型转换和返回不同的类型值

### 4.7.3左值(lval)

指可以出现在赋值运算符左侧的值。一般就是变量、对象属性和数组元素等。

### 4.7.4运算符的副作用

指"++" "=" delete等会运算符会改变操作数(变量)的值，从而产生副作用

### 4.7.5运算符优先级

优先级高的运算符的执行总是优先于优先级低的运算符。优先级相同的运算符按照运算顺序执行。
可以使用圆括号“()”来改变运算符的执行顺序，因为圆括号有着最高的优先级(当然，此圆括号不是指函数调用，new有参时的圆括号),但不是说`a*(b+c)`是先计算b+c，更像是将圆括号内的表达式们看做了一个整体的自表达式，对外界而言其内部的运算符运行顺序不受外界影响。

### 4.7.6运算符的结合性

L表示从左往右结合，R表示从右往左结合。结合性指定了同一表达式中的多个具有相同优先级的运算符的运算顺序。

一般来说一元运算符、赋值和三目运算符都具有R-->的结合性

### 4.7.7运算顺序

运算符的优先级和结合性规定了运算符在复杂表达式中的运算顺序，但是并没有规定运算符的操作数或者说子表达式的运算顺序。JavaScript总是严格按照从左往右的顺序来计算子表达式。比如，`w=x+y*z`中先计算表达式w，然后依次计算x，y，z表达式，然后才是运算符计算表达式的返回结果，即y*z然后+x最后赋值给w表达式的返回值。
对于副作用的运算符，比如`a=1;b=(a++)+a`最终b等于3

## 算术表达式

1. 基本的算术运算符包括`+ - * / %`
2. 除去`+`运算符外，剩余4个运算符都是将操作数先转化为数字然后进行相应的计算。无法转为数字的操作数转为NaN，操作数是NaN将导致算符运算符的结果也是NaN（`+除外 NaN+"a"//"NaNa"`）。
3. 运算符`/`：结果都是浮点型；`?/0`可能返回无穷大和无穷小，`0/0`返回NaN，所有运算均不报错
4. 运算符`%`：`?%?`结果的符号和第一个操作数的符号保持一致；第二个操作数是负数可以直接取绝对值变作正数使用。一般用于正数，也可以用于浮点数(注意精度不准)

### 4.8.1`"+"`运算符

计算时的行为表现如下：

1. 如果有操作数是对象，遵循对象到原始值的转换规则转换为原始值(具体看这里3.8.3):日期对象toString()，其他对象valueOf()
没有valueOf()则调用toString
2. 当操作数都是原始值以后，如果有一个操作数是字符串，那么另一个操作数也会转换为字符串，然后进行字符串的拼接
3. 否则，两个操作数都转化为数字(或者NaN)，然后相加

```js
2+null//0
2+undefined//NaN
true+true//2
1+{}//"1[object Object]"
```

注意运算符结合性和优先级的问题

```js
1+2+"3"//"33"
1+(2+"3")//"123"
```

### 4.8.2一元运算符

作用于单个操作数，并产生一个新值。一般来说具有高优先级，右结合性，且会将操作转为`数字`

1. `+和-`：操作数转为数字
2. `"++和--"`：操作数转为数字；操作数必须是左值；分为前增量和后增量。`a=1;b=1;a+++b;//(a++)+b`

### 4.8.3位运算符

这里归为算术运算，JavaScript中不常用。

1. 要求操作数是整数，由32位整数表示，而不是64位浮点数
2. 先将操作数转为数字，然后强制表示为32整数，忽略小数部分和超过32位的部分。（不是很清楚）并且舍弃第5位之后的二进制位，一边生成一个正确的数字。
3. `NaN Infinity -Infinity`转为0

**按位与&**
对两边的整形操作数执行按位与（and）操作，`0x1234&0x00ff=0x0034`

**按位或|**
对两边的整形操作数执行按位或（or）操作，`0x1234&0x00ff=0x12ff`

**按位异或^**
对两边的整形操作数执行按位异或（xor）操作，对应为位不同返回1，相同返回0`0xff00&0xf0f0=0x0f0f`

**按位非~**
对两边的整形操作数执行按位非操作，`~0xff=0xfffffff0(32位)或者-16`。相当于数值上取反-1，`取反+1=取负号（0和最小负数除外）`

**左移<<**
32位整数，舍去左边的移除位，其余位依次左移动，新位由0补充。相当于乘以2。`7<<2=28`：简单说只要没有超过范围就简单的乘以2，超过了相当于减去(加上)`|MIN|`然后在乘以2(详细细节看图)
![左移](/blog/images/js/4-8-3左移.jpg)

**带符号位右移>>**
32位整数，舍去右边的移除位，其余位依次右移动，新位由符号位补充。(详细看图)
![右移](/blog/images/js/4-8-3右移.jpg)

**无符号右移>>>**
和带符号右移>>相似，只是新位由0补充，而不是符号位。
此时正数规则同`>>`一样，不变；负数相比于原来的结果在数值上会加上一个`|MIN|`

## 4.9关系运算符

关系运算符用于测试两个值之间的关系，根据关系是否存在返回true或者false。(in 和 instanceof也是关系运算符)

## 4.9.1相等和不相等运算符

`==`:相等运算符`===`：严格相等运算符。`!=` `!==`是这两个运算符的结果取反。

3.7节提到过，对象比较的是引用，而不是值本身。例如两个不同的对象具有相同的属性名和值，它们依然不相等；值相同的两个数组依旧是不相等的。

**严格相等运算符`===`**

- 会先计算表达式得出两个操作数的值，然后比较这两个值，过程中`===`不会对操作数进行类型转换。

1. 如果两个操作数类型不相同，返回fasle（所以后面只讨论类型相同的情况）
2. 如果两个操作数都是null或者都是undefined，返回true
3. 如果两个操作数都是布尔值true或者都是false，返回true
4. 其中一个是NaN，或者两个都是NaN，返回false。（NaN和任何值包括`自己`都是不相等的。通过`x!==x`来判断x是不是NaN）
5. 如果两个操作数都是数字，且相等，返回true；0和-0也返回true
6. 如果两个操作数都是字符串，且对应位上的16位Unicode(3.2)相等，则返回true。
因为JavaScript没有进行标准化Unicode转换，所以有时两个字符串显示一样，但是具有不同的编码，导致返回false。String.localeCompare()提供了另外一种比较字符串的方法。
7. 如果两个引用指向同一个对象、数组或函数，则它们是相等的，返回true。如果引用指向不同的对象，则返回false，尽管它们包含的内容一样。

**相等运算符`==`**

- 相比于`===`，`==`有一点不严格。即如果两个操作数不是同一类型，会进行类型转换。

1. 类型相同则依照`===`的规则判断（否则类型不同，进入如下步骤）
2. 如果一个是null，一个是undefined，返回true
3. 一个是数字，一个字符串，字符串转为数字，然后比较。
4. `true false`均转为数字`1 0`后再比较
5. 如果一个是对象，另外一个是数字或者字符串，那么对象先转为原始值，在比较。（对象怎么转为原始值看第3章）
6. 其他情况返回false

### 4.9.2比较运算符（`< > <= >=`）

- 所有的操作数会转化为数字和字符串（当然除去数字和字符串）

1. 如果操作数是对象，转为原始值(3.8.3)
2. 对象转换为原始后，如果操作数都是字符串，依照16Unicode码进行比较
3. 对象转换为原始后，如果至少有一个操作数不是字符串，那么两个操作数都转为数字。NaN永远返回false，0 -0相等，Infinity最大-Infinity最小。

- "+"偏爱字符串，比较运算偏爱数字。
- String.localCompare()比较字符串更为的健壮；使用String.toLowerCase(),String.toUpperCase()做大小写转换
- `<= >=`在判断相等的时候并不依赖于`==和===`，只是简单的‘不大于’或者‘不小于’

### 4.9.3`in`运算符

- `in`希望左边操作数是字符串（或者转换为字符串），希望右边是一个对象。
- 如果右侧对象有名为左侧操作数的值的属性，返回true。

### 4.9.4`instanceof`运算符

- `instanceof`希望左边是一个对象，右边是一个表示对象的类（函数）。如果左边对象是右边对象的实例，返回true。
- 如果左操作数不是对象，返回false`"a" instanceof String//false 不会进行包装类转化`；右操作数不是函数，抛出类型错误异常。
- instanceof运算符的工作原理和原型链相关。`i instanceof f`中会先计算f.prototype 然后在o的原型链中寻找f.prototype，找到就返回true，找不到返回false。

## 4.10逻辑运算符（`&& || !`）

`&& || !`对操作数进行布尔计算。优先级低于关系运算符

### 4.10.1逻辑与(&&)

可以分为三个不同的层次理解（先计算左边表达式）

1. 当操作数都是布尔值时，返回布尔与运算(AND)的结果
2. 操作数不一定非要是布尔值，因为操作数分为真值和假值，所以最终的返回值也为真值和假值，而不一定是true和false
3. 逻辑与运算&&存在短路，如果第一个操作数是假值，则返回第一个操作数，且第二个操作数不会进行运算；否则第一个操作数是真值，返回第二个操作数运算结果。

例子

```js
var o={x:1}；
var p=null；
o && o.x//1 返回o.x
p && p.x//null ：p是假值，将其返回，并不计算p.x,所以不报错

以下运行流程等价（只是后一个表达式由返回值，前一个if语句没有返回值）
if(a==b) stop();
(a==b)&&stop();
所以可以替代if语句，只有条件全部成立才执行最后的语句。
```

多数情况下，&&仅用来做真值和假值的布尔运算。

### 4.10.2逻辑或||

和&&运算一样具有三层意思，常用用于从一组备选表达式中选出第一个真值表达式

```js
在前面两个值都为假值的情况下，提供一个500的默认参数。
var max = max_width||preferences.max_width||500;

function copy(o, p) {
  p = p || {};//没有传入参数p，则默认赋值为一个空对象
}
```

### 4.10.3逻辑非(!)

- !运算符是一个单目运算符，用于将操作数的布尔值取反。如果x是真值那么`!x`返回`false`，如果x是假值那么`!x`返回`true`
- 和`&& ||`运算符不同，`!`会将操作数转化为布尔值，然后在取反。`!!x等价于Boolean(x)`

```js
!(p && q)===!p || !q
!(p || q)===!p && !q
```

## 4.11赋值表达式

JavaScript使用`=`运算符来给变量或者属性赋值。

1. 左操作数必须是一个左值，右操作数可以任何类型的任意值；返回值为赋值给左操作数的值（说白了就是右操作数的运算值）；结合性从右往左；具有副作用；优先级基本最低

**带操作的赋值运算**`+= -= *= /= %= <<= >>= >>>= &= |= ^=`

```js
下列两个表达式是有不同的
a op= b //表达式a只计算了一次，计算表达式a，表达式b，然后计算a*b并赋值给a
a = a op b //表达式a计算了两次，计算表达式a1, 表达式a2，表达式b 然后计算a2*b赋值给a1(a1表示左边的a，a2表示右边的)

比如
data[i++] *= 2 //等价于data[i]=date[i]*2
data[i++]=data[i++] * 2 //等价于data[i]=date[i+1]*2
```

## 4.12表达式计算(eval)

JavaScript可以动态的解释运行由JavaScript源代码组成的字符串，并产生一个值。这些都通过全局函数eval()来完成。

这是一个强大的语言特性，几乎没有必要在开发中使用。

通过测试得知eval是一个函数，可以复制给任何变量，然后再通过变量调用该函数。

### 4.12.1 eval()

1. eval()函数只有一个参数，如果不是字符串则直接返回这个参数。
2. 参数是字符串则会当做JavaScript代码编译，编译失败会抛出语法错误异常。
3. 编译成功则会开始执行这段代码，并返回字符串中最后一个表达式或语句的值，如果最后一个表达式或语句没有值，则最终返回undefined，如果运行时抛出异常，则会往外抛出。
4. eval()函数的变量作用域环境由调用所在地决定。放在最顶层就是全局环境
5. eval函数的执行上下文环境和调用上下文环境是一样的。

### 4.12.2全局eval()

eval如果通过别名调用，只能在全局上下文中执行(不能访问局部变量和函数)；如果直接调用eval,则在调用它的上下文作用域中执行(可以访问局部变量和函数)。

```js
例子看书吧。。HIA
```

IE中没有eval() 只有execScript(),不详述

### 4.12.3严格eval()

"use strict":eval不能别名...不详述

## 4.13其他运算符

### 4.13.1条件运算符(?:)

1. 有三个操作数，都可以为任何值。
2. 如果第一个操作数是真值，那么计算第二个操作数，并返回结果；如果是假值，那么计算第三个操作数，并返回结果；不能两个操作数都计算。
3. 和使用if一样?:只会一种简写。

```js
常用场景:判断一个值是否用定义(准确来说是判断是为真值还是假值)，没有定义设置为默认值
greeting = "hello" + (username ? username : "there")
```

### 4.13.2 typeof运算符

是一元运算符，操作数可以是任何类型，返回值为一个操作数类型的字符串。

```js
undefined     "undefined"
null          "object"
true或false   "boolean"
数字或NaN      "number"
字符串         "string"
函数           "function"（包括可执行对象）
内置对象(非函数) "object"
宿主对象        浏览器厂商各自的编译器决定的字符串
               不能是"undefined boolean number string"
```

可以带括号`typeof(???)`

想区分对象的类，则需要使用其他手段，比如instanceof class特性 constructor属性。

### 4.13.3 delete运算符

一元运算符，用于删除对象的属性或者数组元素；有副作用

```js
var o = {x:1, y:2};
delete o.x; //删除一个属性
"x" in o;  //false

var a = [1, 2, 3];
delete a[2]; //删除最后一个数组元素
2 in a;  //false
a.length //3:长度比并未有变化，删除操作留下了一个'洞',而并没有改变数组的长度。
```

1. delete不是说将属性设置为undefined，而是整个属性都不存在了。（虽然读取不存在的属性或赋值为undefined的属性都返回undefined，但是可以通过 in 运算符来检测这个属性是否存在）
2. delete希望操作数是一个左值，不是左值则不进行任何操作并返回true；是左值则试图删除，成功返回true，失败返回false；不能删除var 定义的变量(var定义的全局变量?)，function语句定义的函数和函数参数（最后一句有点没懂,只知道属性的可配置性与delete相关）。
3. 严格模式 。。。。

### 4.13.4 void运算符

一元运算符，出现在操作数之前，操作数类型任意。可以让操作数正常计算，但是会忽略计算结果并将返回值变为undefined。

### 4.13.5 逗号运算符(,)

二元运算符，操作数类型任意，结合性为L。先计算左操作数，在计算右操作数，最后返回右操作数。优先级比赋值`=`还要低。
`i=0, j=1, k=2;  //结果是2`
